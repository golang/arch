// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build go1.19

// riscv64spec reads the riscv-opcodes repo
// to collect instruction encoding details.
// Repo url: https://github.com/riscv/riscv-opcodes
// usage: riscv64spec

package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
)

// Reference: RISC-V ISA Maunal Volume 1 Chapter 27, RV32/64G Instruction Set Listings.
var extentions = []string{"rv_i", "rv64_i", "rv_zifencei", "rv_zicsr", "rv_m", "rv64_m", "rv_a", "rv64_a", "rv_f", "rv64_f", "rv_d", "rv64_d", "rv_q", "rv64_q", "rv_zfh", "rv64_zfh"}

var fileNames = []string{"prolugue.tmp", "op.tmp", "opstr.tmp", "instFormats.tmp"}

var files = map[string]string{
	"prolugue.tmp":    "// Generated by riscv64spec riscv-opcodes\n// DO NOT EDIT\n\n// Copyright 2023 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage riscv64asm\n\n",
	"op.tmp":          "const (\n\t_ Op = iota\n",
	"opstr.tmp":       "var opstr = [...]string{\n",
	"instFormats.tmp": "var instFormats = [...]instFormat{\n",
}

var ops []string
var opstrs = make(map[string]string)
var instFormatComments = make(map[string]string)
var instFormats = make(map[string]string)

func main() {
	log.SetFlags(0)
	log.SetPrefix("riscv64spec: ")

	var fds [4]*os.File

	for i, fn := range fileNames {
		fd, _ := os.OpenFile(fn, os.O_RDWR|os.O_CREATE, 0664)
		defer os.Remove(fn)
		fd.Write([]byte(files[fn]))
		fds[i] = fd
	}

	for _, ext := range extentions {
		f, err := os.Open("riscv-opcodes/" + ext)
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()

		buf := bufio.NewScanner(f)
		for {
			if !buf.Scan() {
				break
			}
			line := buf.Text()
			if len(line) == 0 {
				continue
			}
			words := strings.Split(line, " ")
			if words[0][0] == '#' || words[0][0] == '$' {
				continue
			}

			getInst(words)
		}
	}

	sort.Strings(ops)

	for _, op := range ops {
		// 1. write op
		fds[1].Write([]byte(fmt.Sprintf("\t%s\n", op)))
		// 2. write opstr
		fds[2].Write([]byte(fmt.Sprintf("\t%s\n", opstrs[op])))
		// 3. write instFormatComment and instFormat
		fds[3].Write([]byte(fmt.Sprintf("\t%s\n\t%s\n", instFormatComments[op], instFormats[op])))
	}

	fds[1].Write([]byte(")\n\n"))
	fds[2].Write([]byte("}\n\n"))
	fds[3].Write([]byte("}\n"))

	fileTables, err := os.Create("tables.go")
	defer fileTables.Close()

	for _, fd := range fds {
		fd.Seek(0, io.SeekStart)
		if _, err = io.Copy(fileTables, fd); err != nil {
			fmt.Println("File copy error")
		}
		fd.Close()
	}

	fileTables.Close()
}

func getInst(words []string) (string, string, string) {
	op := strings.ToUpper(strings.Replace(words[0], ".", "_", -1))
	opstr := fmt.Sprintf("%s:\t\"%s\",", op, strings.ToUpper(words[0]))

	var value uint32
	var mask uint32
	var instArgs []string

	for i := 1; i < len(words); i++ {
		if strings.Contains(words[i], "..") {
			val := strings.Split(words[i], "=")
			sec := strings.Split(val[0], "..")
			subval, submsk := genValueAndMask(val, sec)
			value |= subval
			mask |= submsk
		} else if len(words[i]) > 0 {
			instArgs = append(instArgs, words[i])
		}
	}

	instArgsStr := deferFormats(instArgs, op)
	instFormatComment := "// " + strings.Replace(op, "_", ".", -1) + " " + strings.Replace(instArgsStr, "arg_", "", -1)
	instFormat := fmt.Sprintf("{mask: %#08x, value: %#08x, op: %s, args: instArgs{%s}},", mask, value, op, instArgsStr)

	// Handle the suffix of atomic instruction.
	if isAtomic(op) {
		suffix := []string{"", ".RL", ".AQ", ".AQRL"}
		// Re-generate the opcode string, opcode value and mask.
		for i, suf := range suffix {
			aop := op + strings.Replace(suf, ".", "_", -1)
			aopstr := fmt.Sprintf("%s:\t\"%s\",", aop, strings.ToUpper(words[0])+suf)
			avalue := value | (uint32(i) << 25)
			amask := mask | 0x06000000
			ainstFormatComment := "// " + strings.Replace(aop, "_", ".", -1) + " " + strings.Replace(instArgsStr, "arg_", "", -1)
			ainstFormat := fmt.Sprintf("{mask: %#08x, value: %#08x, op: %s, args: instArgs{%s}},", amask, avalue, aop, instArgsStr)
			ops = append(ops, aop)
			opstrs[aop] = aopstr
			instFormats[aop] = ainstFormat
			instFormatComments[aop] = ainstFormatComment
		}
	} else {
		ops = append(ops, op)
		opstrs[op] = opstr
		instFormats[op] = instFormat
		instFormatComments[op] = instFormatComment
	}

	return op, opstr, instFormat
}

// Defer inst format:
// R-Type (inst rd, rs1, rs2),
// I-Type (inst rd, rs1, imm / inst rd, offset(rs1)),
// UJ-Type (inst rd, imm),
// U-Type (inst rd, imm),
// SB-Type (inst rs1, rs2, offset)
// S-Type (inst rs2, offset(rs1))
func deferFormats(instArgs []string, op string) string {
	switch {
	case strings.Contains(op, "AMO") || strings.Contains(op, "SC_"):
		return "arg_rd, arg_rs2, arg_rs1_amo"

	case strings.Contains(op, "LR_"):
		return "arg_rd, arg_rs1_amo"

	case op == "LB" || op == "LBU" || op == "LD" ||
		op == "LH" || op == "LHU" || op == "LW" || op == "LWU":
		return "arg_rd, arg_rs1_mem"

	case op == "FLD" || op == "FLW" || op == "FLH" || op == "FLQ":
		return "arg_fd, arg_rs1_mem"

	case op == "FSD" || op == "FSW" || op == "FSH" || op == "FSQ":
		return "arg_fs2, arg_rs1_store"

	case op == "SD" || op == "SB" || op == "SW" || op == "SH":
		return "arg_rs2, arg_rs1_store"

	case op == "CSRRW" || op == "CSRRS" || op == "CSRRC":
		return "arg_rd, arg_csr, arg_rs1"

	case op == "CSRRWI" || op == "CSRRSI" || op == "CSRRCI":
		return "arg_rd, arg_csr, arg_zimm"

	case op == "JALR":
		return "arg_rd, arg_rs1_mem"

	case op == "FENCE_I":
		return ""

	case op == "FENCE":
		return "arg_pred, arg_succ"

	default:
		var instStr []string
		for _, arg := range instArgs {
			if decodeArgs(arg, op) != "" {
				instStr = append(instStr, decodeArgs(arg, op))
			}
		}
		return strings.Join(instStr, ", ")
	}
}

// Turn the args into formats defined in arg.go
func decodeArgs(arg string, op string) string {
	switch {
	case strings.Contains("arg_rd", arg):
		if isFloatReg(op, "rd") {
			return "arg_fd"
		} else {
			return "arg_rd"
		}

	case strings.Contains("arg_rs1", arg):
		if isFloatReg(op, "rs") {
			return "arg_fs1"
		} else {
			return "arg_rs1"
		}

	case strings.Contains("arg_rs2", arg):
		if isFloatReg(op, "rs") {
			return "arg_fs2"
		} else {
			return "arg_rs2"
		}

	case strings.Contains("arg_rs3", arg):
		if isFloatReg(op, "rs") {
			return "arg_fs3"
		} else {
			return "arg_rs3"
		}

	case arg == "imm12":
		return "arg_imm12"

	case arg == "imm20":
		return "arg_imm20"

	case arg == "jimm20":
		return "arg_jimm20"

	case arg == "bimm12lo":
		return "arg_bimm12"

	case arg == "imm12lo":
		return "arg_simm12"

	case arg == "shamtw":
		return "arg_shamt5"

	case arg == "shamtd":
		return "arg_shamt6"
	}
	return ""
}

// Generate instruction value and relative mask.
func genValueAndMask(valStr []string, secStr []string) (uint32, uint32) {
	var val int64

	if strings.Contains(valStr[1], "0x") {
		hexStr := strings.Replace(valStr[1], "0x", "", -1)
		val, _ = strconv.ParseInt(hexStr, 16, 32)
	} else {
		val, _ = strconv.ParseInt(valStr[1], 10, 32)
	}

	l, _ := strconv.Atoi(secStr[0])
	r, _ := strconv.Atoi(secStr[1])

	var subval uint32
	var submsk uint32
	subval = uint32(val << r)
	submsk = ^uint32(0)
	submsk = submsk << (31 - l) >> (31 - l + r) << r
	return subval, submsk
}

// Defer whether the instruction is atomic or not.
func isAtomic(op string) bool {
	if strings.Contains(op, "AMO") || strings.Contains(op, "LR_") || strings.Contains(op, "SC_") {
		return true
	}
	return false
}

// Defer whether the reg of floating-point instruction is freg or not.
func isFloatReg(op string, reg string) bool {
	switch {
	case strings.Contains(op, "FADD") || strings.Contains(op, "FSUB") ||
		strings.Contains(op, "FDIV") || strings.Contains(op, "FMUL") ||
		strings.Contains(op, "FMIN") || strings.Contains(op, "FMAX") ||
		strings.Contains(op, "FMADD") || strings.Contains(op, "FMSUB") ||
		strings.Contains(op, "FCVT_D_S") || strings.Contains(op, "FCVT_S_D") ||
		strings.Contains(op, "FCVT_D_Q") || strings.Contains(op, "FCVT_Q_D") ||
		strings.Contains(op, "FCVT_S_Q") || strings.Contains(op, "FCVT_Q_S") ||
		strings.Contains(op, "FCVT_H_S") || strings.Contains(op, "FCVT_S_H") ||
		strings.Contains(op, "FNM") || strings.Contains(op, "FNEG") ||
		strings.Contains(op, "FSQRT") || strings.Contains(op, "FSGNJ"):
		return true

	case strings.Contains(op, "FCLASS") || strings.Contains(op, "FCVT_L") ||
		strings.Contains(op, "FCVT_W") || strings.Contains(op, "FEQ") ||
		strings.Contains(op, "FLE") || strings.Contains(op, "FLT") ||
		strings.Contains(op, "FMV_X_H") || strings.Contains(op, "FMV_X_D") ||
		strings.Contains(op, "FMV_X_W"):
		return reg != "rd"

	case strings.Contains(op, "FCVT_D") || strings.Contains(op, "FCVT_S") ||
		strings.Contains(op, "FCVT_H") || strings.Contains(op, "FCVT_Q") ||
		strings.Contains(op, "FMV_H_X") || strings.Contains(op, "FMV_D_X") ||
		strings.Contains(op, "FMV_W_X"):
		return reg != "rs"

	default:
		return false
	}
}
