// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"slices"
	"sort"
	"strings"
)

type simdType struct {
	Name                    string // The go type name of this simd type, for example Int32x4.
	Lanes                   int    // The number of elements in this vector/mask.
	Base                    string // The element's type, like for Int32x4 it will be int32.
	Fields                  string // The struct fields, it should be right formatted.
	Type                    string // Either "mask" or "vreg"
	VectorCounterpart       string // For mask use only: just replacing the "Mask" in [simdType.Name] with "Int"
	ReshapedVectorWithAndOr string // For mask use only: vector AND and OR are only available in some shape with element width 32.
	Size                    int    // The size of the type
}

func compareSimdTypes(x, y simdType) int {
	c := strings.Compare(x.Name, y.Name)
	if c != 0 {
		return c
	}
	return strings.Compare(x.Type, y.Type)
}

type simdTypeMap map[int][]simdType

type simdTypePair struct {
	Tsrc simdType
	Tdst simdType
}

func compareSimdTypePairs(x, y simdTypePair) int {
	c := compareSimdTypes(x.Tsrc, y.Tsrc)
	if c != 0 {
		return c
	}
	return compareSimdTypes(x.Tdst, y.Tdst)
}

const simdTypesTemplates = `{{define "fileHeader"}}// Code generated by x/arch/internal/simdgen using 'go run . -xedPath $XED_PATH -o godefs -goroot $GOROOT go.yaml types.yaml categories.yaml'; DO NOT EDIT.

//go:build goexperiment.simd

package simd
{{end}}

{{define "sizeTmpl"}}
// v{{.}} is a tag type that tells the compiler that this is really {{.}}-bit SIMD
type v{{.}} struct {
	_{{.}} struct{}
}
{{end}}

{{define "typeTmpl"}}
// {{.Name}} is a {{.Size}}-bit SIMD vector of {{.Lanes}} {{.Base}}
type {{.Name}} struct {
{{.Fields}}
}

{{- if ne .Type "mask"}}

// Len returns the number of elements in a {{.Name}}
func (x {{.Name}}) Len() int { return {{.Lanes}} }

// Load{{.Name}} loads a {{.Name}} from an array
//
//go:noescape
func Load{{.Name}}(y *[{{.Lanes}}]{{.Base}}) {{.Name}}

// Store stores a {{.Name}} to an array
//
//go:noescape
func (x {{.Name}}) Store(y *[{{.Lanes}}]{{.Base}})

{{- end}}
{{end}}
`

const simdStubsTmpl = `{{define "fileHeader"}}// Code generated by x/arch/internal/simdgen using 'go run . -xedPath $XED_PATH -o godefs -goroot $GOROOT go.yaml types.yaml categories.yaml'; DO NOT EDIT.

//go:build goexperiment.simd

package simd{{end}}
{{define "op1"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 0).Go}}) {{.Go}}() {{(index .Out 0).Go}}{{end}}

{{define "op2"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 0).Go}}) {{.Go}}(y {{(index .In 1).Go}}) {{(index .Out 0).Go}}{{end}}

{{define "op3"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 0).Go}}) {{.Go}}(y {{(index .In 1).Go}}, z {{(index .In 2).Go}}) {{(index .Out 0).Go}}{{end}}

{{define "op4"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 0).Go}}) {{.Go}}(y {{(index .In 1).Go}}, z {{(index .In 2).Go}}, u {{(index .In 3).Go}}) {{(index .Out 0).Go}}{{end}}

{{define "op1Imm8"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 1).Go}}) {{.Go}}(imm8 uint8) {{(index .Out 0).Go}}{{end}}

{{define "op2Imm8"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 1).Go}}) {{.Go}}(imm uint8, y {{(index .In 2).Go}}) {{(index .Out 0).Go}}{{end}}

{{define "op3Imm8"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 1).Go}}) {{.Go}}(imm uint8, y {{(index .In 2).Go}}, z {{(index .In 3).Go}}) {{(index .Out 0).Go}}{{end}}

{{define "op4Imm8"}}
{{if .Documentation}}
{{.Documentation}}
//{{end}}
// Asm: {{.Asm}}, CPU Feature: {{.Extension}}
func (x {{(index .In 1).Go}}) {{.Go}}(imm uint8, y {{(index .In 2).Go}}, z {{(index .In 3).Go}}, u {{(index .In 4).Go}}) {{(index .Out 0).Go}}{{end}}

{{define "vectorConversion"}}
// {{.Tdst.Name}} converts from {{.Tsrc.Name}} to {{.Tdst.Name}}
func (from {{.Tsrc.Name}}) As{{.Tdst.Name}}() (to {{.Tdst.Name}})
{{end}}

{{define "mask"}}
// converts from {{.Name}} to {{.VectorCounterpart}}
func (from {{.Name}}) As{{.VectorCounterpart}}() (to {{.VectorCounterpart}})

// converts from {{.VectorCounterpart}} to {{.Name}}
func (from {{.VectorCounterpart}}) As{{.Name}}() (to {{.Name}})

func (x {{.Name}}) And(y {{.Name}}) {{.Name}}

func (x {{.Name}}) Or(y {{.Name}}) {{.Name}}
{{end}}
`

// parseSIMDTypes groups go simd types by their vector sizes, and
// returns a map whose key is the vector size, value is the simd type.
func parseSIMDTypes(ops []Operation) simdTypeMap {
	// TODO: maybe instead of going over ops, let's try go over types.yaml.
	ret := map[int][]simdType{}
	seen := map[string]struct{}{}
	processArg := func(arg Operand) {
		if arg.Class == "immediate" {
			// Immediates are not encoded as vector types.
			return
		}
		if _, ok := seen[*arg.Go]; ok {
			return
		}
		seen[*arg.Go] = struct{}{}
		lanes := *arg.Bits / *arg.ElemBits
		base := fmt.Sprintf("%s%d", *arg.Base, *arg.ElemBits)
		tagFieldNameS := fmt.Sprintf("%sx%d", base, lanes)
		tagFieldS := fmt.Sprintf("%s v%d", tagFieldNameS, *arg.Bits)
		valFieldS := fmt.Sprintf("vals%s[%d]%s", strings.Repeat(" ", len(tagFieldNameS)-3), lanes, base)
		fields := fmt.Sprintf("\t%s\n\t%s", tagFieldS, valFieldS)
		if arg.Class == "mask" {
			vectorCounterpart := strings.ReplaceAll(*arg.Go, "Mask", "Int")
			reshapedVectorWithAndOr := fmt.Sprintf("Int32x%d", *arg.Bits/32)
			ret[*arg.Bits] = append(ret[*arg.Bits], simdType{*arg.Go, lanes, base, fields, arg.Class, vectorCounterpart, reshapedVectorWithAndOr, *arg.Bits})
			// In case the vector counterpart of a mask is not present, put its vector counterpart typedef into the map as well.
			if _, ok := seen[vectorCounterpart]; !ok {
				seen[vectorCounterpart] = struct{}{}
				ret[*arg.Bits] = append(ret[*arg.Bits], simdType{vectorCounterpart, lanes, base, fields, "vreg", "", "", *arg.Bits})
			}
		} else {
			ret[*arg.Bits] = append(ret[*arg.Bits], simdType{*arg.Go, lanes, base, fields, arg.Class, "", "", *arg.Bits})
		}
	}
	for _, op := range ops {
		for _, arg := range op.In {
			processArg(arg)
		}
		for _, arg := range op.Out {
			processArg(arg)
		}
	}
	return ret
}

func vConvertFromTypeMap(typeMap simdTypeMap) []simdTypePair {
	v := []simdTypePair{}
	for _, ts := range typeMap {
		for i, tsrc := range ts {
			for j, tdst := range ts {
				if i != j && tsrc.Type == tdst.Type && tsrc.Type == "vreg" {
					v = append(v, simdTypePair{tsrc, tdst})
				}
			}
		}
	}
	slices.SortFunc(v, compareSimdTypePairs)
	return v
}

func masksFromTypeMap(typeMap simdTypeMap) []simdType {
	m := []simdType{}
	for _, ts := range typeMap {
		for _, tsrc := range ts {
			if tsrc.Type == "mask" {
				m = append(m, tsrc)
			}
		}
	}
	slices.SortFunc(m, compareSimdTypes)
	return m
}

// writeSIMDTypes generates the simd vector type and writes it to types_amd64.go
// within the specified directory.
func writeSIMDTypes(directory string, typeMap simdTypeMap) error {
	file, t, err := openFileAndPrepareTemplate(directory, "src/"+simdPackage+"/types_amd64.go", simdTypesTemplates)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := t.ExecuteTemplate(file, "fileHeader", nil); err != nil {
		return fmt.Errorf("failed to execute fileHeader template: %w", err)
	}

	sizes := make([]int, 0, len(typeMap))
	for size := range typeMap {
		sizes = append(sizes, size)
	}
	sort.Ints(sizes)

	for _, size := range sizes {
		if err := t.ExecuteTemplate(file, "sizeTmpl", size); err != nil {
			return fmt.Errorf("failed to execute size template for size %d: %w", size, err)
		}
		for _, typeDef := range typeMap[size] {
			if err := t.ExecuteTemplate(file, "typeTmpl", typeDef); err != nil {
				return fmt.Errorf("failed to execute type template for type %s: %w", typeDef.Name, err)
			}
		}
	}

	return nil
}

// writeSIMDStubs generates the simd vector intrinsic stubs and writes it to stubs_amd64.go
// within the specified directory.
func writeSIMDStubs(directory string, ops []Operation, typeMap simdTypeMap) error {
	file, t, err := openFileAndPrepareTemplate(directory, "src/"+simdPackage+"/stubs_amd64.go", simdStubsTmpl)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := t.ExecuteTemplate(file, "fileHeader", nil); err != nil {
		return fmt.Errorf("failed to execute fileHeader template: %w", err)
	}

	slices.SortFunc(ops, compareOperations)

	for i, op := range ops {
		if s, op, err := classifyOp(op); err == nil {
			if i == 0 || op.Go != ops[i-1].Go {
				fmt.Fprintf(file, "\n\n// %s", op.Go)
			}
			if err := t.ExecuteTemplate(file, s, op); err != nil {
				return fmt.Errorf("failed to execute template %s for op %s: %w", s, op.Go, err)
			}

		} else {
			return fmt.Errorf("failed to classify op %v: %w", op.Go, err)
		}
	}

	vectorConversions := vConvertFromTypeMap(typeMap)
	for _, conv := range vectorConversions {
		if err := t.ExecuteTemplate(file, "vectorConversion", conv); err != nil {
			return fmt.Errorf("failed to execute vectorConversion template: %w", err)
		}
	}

	masks := masksFromTypeMap(typeMap)
	for _, mask := range masks {
		if err := t.ExecuteTemplate(file, "mask", mask); err != nil {
			return fmt.Errorf("failed to execute mask template for mask %s: %w", mask.Name, err)
		}
	}

	return nil
}
