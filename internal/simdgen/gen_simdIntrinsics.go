// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
)

const simdIntrinsicsTmpl = `// Code generated by x/arch/internal/simdgen using 'go run . -xedPath $XED_PATH -o godefs -goroot $GOROOT go.yaml types.yaml categories.yaml'; DO NOT EDIT.
package ssagen

import (
	"cmd/compile/internal/ir"
	"cmd/compile/internal/ssa"
	"cmd/compile/internal/types"
	"cmd/internal/sys"
)

const simdPackage = "` + simdPackage + `"

func simdIntrinsics(addF func(pkg, fn string, b intrinsicBuilder, archFamilies ...sys.ArchFamily)) {
{{- range .OpsLen1}}
	addF(simdPackage, "{{(index .In 0).Go}}.{{.Go}}", opLen1(ssa.Op{{.Go}}{{(index .In 0).Go}}, {{.GoArch}}), sys.AMD64)
{{- end}}
{{- range .OpsLen2}}
	addF(simdPackage, "{{(index .In 0).Go}}.{{.Go}}", opLen2(ssa.Op{{.Go}}{{(index .In 0).Go}}, {{.GoArch}}), sys.AMD64)
{{- end}}
{{- range .OpsLen3}}
	addF(simdPackage, "{{(index .In 0).Go}}.{{.Go}}", opLen3(ssa.Op{{.Go}}{{(index .In 0).Go}}, {{.GoArch}}), sys.AMD64)
{{- end}}
{{- range .OpsLen4}}
	addF(simdPackage, "{{(index .In 0).Go}}.{{.Go}}", opLen4(ssa.Op{{.Go}}{{(index .In 0).Go}}, {{.GoArch}}), sys.AMD64)
{{- end}}
{{- range .OpsLen1Imm8}}
	addF(simdPackage, "{{(index .In 1).Go}}.{{.Go}}", opLen1Imm8(ssa.Op{{.Go}}{{(index .In 1).Go}}, {{.GoArch}}, {{(index .In 0).ImmOffset}}), sys.AMD64)
{{- end}}
{{- range .OpsLen2Imm8}}
	addF(simdPackage, "{{(index .In 1).Go}}.{{.Go}}", opLen2Imm8(ssa.Op{{.Go}}{{(index .In 1).Go}}, {{.GoArch}}, {{(index .In 0).ImmOffset}}), sys.AMD64)
{{- end}}
{{- range .OpsLen3Imm8}}
	addF(simdPackage, "{{(index .In 1).Go}}.{{.Go}}", opLen3Imm8(ssa.Op{{.Go}}{{(index .In 1).Go}}, {{.GoArch}}, {{(index .In 0).ImmOffset}}), sys.AMD64)
{{- end}}
{{- range .OpsLen4Imm8}}
	addF(simdPackage, "{{(index .In 1).Go}}.{{.Go}}", opLen4Imm8(ssa.Op{{.Go}}{{(index .In 1).Go}}, {{.GoArch}}, {{(index .In 0).ImmOffset}}), sys.AMD64)
{{- end}}

{{- range .VectorConversions }}
	addF(simdPackage, "{{.Tsrc.Name}}.As{{.Tdst.Name}}", func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value { return args[0] }, sys.AMD64)
{{- end}}

{{- range $size, $ts := .TypeMap }}
{{- range $t := $ts }}
	addF(simdPackage, "Load{{$t.Name}}", simdLoad(), sys.AMD64)
	addF(simdPackage, "{{$t.Name}}.Store", simdStore(), sys.AMD64)
{{- end}}
{{- end}}
{{- range .Masks }}
	addF(simdPackage, "{{.Name}}.As{{.VectorCounterpart}}", func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value { return args[0] }, sys.AMD64)
	addF(simdPackage, "{{.VectorCounterpart}}.As{{.Name}}", func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value { return args[0] }, sys.AMD64)
	addF(simdPackage, "{{.Name}}.And", opLen2(ssa.OpAnd{{.ReshapedVectorWithAndOr}}, types.TypeVec{{.Size}}), sys.AMD64)
	addF(simdPackage, "{{.Name}}.Or", opLen2(ssa.OpOr{{.ReshapedVectorWithAndOr}}, types.TypeVec{{.Size}}), sys.AMD64)
{{- end}}
}
`

// writeSIMDIntrinsics generates the intrinsic mappings and writes it to simdintrinsics.go
// within the specified directory.
func writeSIMDIntrinsics(directory string, ops []Operation, typeMap simdTypeMap) error {
	file, t, err := openFileAndPrepareTemplate(directory, "src/cmd/compile/internal/ssagen/simdintrinsics.go", simdIntrinsicsTmpl)
	if err != nil {
		return err
	}
	defer file.Close()
	opsLen1, opsLen2, opsLen3, opsLen4, opsLen1Imm8, opsLen2Imm8, opsLen3Imm8, opsLen4Imm8, err := opsByLen(ops)
	if err != nil {
		return err
	}

	type templateData struct {
		OpsLen1           []Operation
		OpsLen2           []Operation
		OpsLen3           []Operation
		OpsLen4           []Operation
		OpsLen1Imm8       []Operation
		OpsLen2Imm8       []Operation
		OpsLen3Imm8       []Operation
		OpsLen4Imm8       []Operation
		TypeMap           simdTypeMap
		VectorConversions []simdTypePair
		Masks             []simdType
	}
	err = t.Execute(file, templateData{opsLen1, opsLen2, opsLen3, opsLen4, opsLen1Imm8, opsLen2Imm8, opsLen3Imm8, opsLen4Imm8, typeMap, vConvertFromTypeMap(typeMap), masksFromTypeMap(typeMap)})
	if err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
